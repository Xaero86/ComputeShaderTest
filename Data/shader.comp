#version 430

uniform int u_computeStep;

uniform int u_nbVertices;
uniform int u_nbEdges;

uniform vec4 u_center;
uniform float u_progress;

// on n'utilise pas uvec3: probleme d'alignement
struct st_face {
    uint x, y, z;
};

layout(std430, binding=0) buffer Vertices{
    vec4 b_vertices[];
};

layout(std430, binding=1) buffer EdgesIn{
    uvec2 b_edgesIn[];
};

layout(std430, binding=2) buffer FacesIn{
    st_face b_facesIn[];
};

layout(std430, binding=3) buffer EdgesOut{
    uvec2 b_edgesOut[];
};

layout(std430, binding=4) buffer FacesOut{
    st_face b_facesOut[];
};

layout(std430, binding=5) buffer FacesVertOut{
    st_face b_facesVertOut[];
};

layout( local_size_x = 1,  local_size_y = 1, local_size_z = 1 ) in;

void main() {
    uint nbVertices = uint(u_nbVertices);
    uint nbEdges = uint(u_nbEdges);
    
    uint index = gl_GlobalInvocationID.x;
    if (u_computeStep == 0) {
        // Calcul des nouveaux sommets au milieu des arretes
        uvec2 current = b_edgesIn[gl_GlobalInvocationID.x];
        vec4 v1 = b_vertices[current.x]-u_center;
        vec4 v2 = b_vertices[current.y]-u_center;
        vec4 mid = (v1 + v2)/2.0;
        float distMin = length(mid);
        float distMax = (length(v1)+length(v2))/2.0;
        float progress = clamp(u_progress, 0.0, 1.0);
        float dist = distMin + progress*(distMax-distMin);
        b_vertices[u_nbVertices + index] = normalize(mid)*dist+u_center;
        // Ajout des nouvelles arretes: ancienne arrete divisee en deux
        b_edgesOut[index*2] = uvec2(current.x, u_nbVertices + index);
        b_edgesOut[index*2+1] = uvec2(current.y, u_nbVertices + index);
    } else if (u_computeStep == 1) {
        st_face current = b_facesIn[index];
        // A partir des 3 arretes de cette face, 3 sommets ont ete crees
        uint newVerticeInd1 = u_nbVertices + current.x;
        uint newVerticeInd2 = u_nbVertices + current.y;
        uint newVerticeInd3 = u_nbVertices + current.z;
        // Calcul des nouvelles arretes a partir des nouveaux sommets
        b_edgesOut[nbEdges*2 + index*3] = uvec2(newVerticeInd2, newVerticeInd3);
        b_edgesOut[nbEdges*2 + index*3+1] = uvec2(newVerticeInd3, newVerticeInd1);
        b_edgesOut[nbEdges*2 + index*3+2] = uvec2(newVerticeInd1, newVerticeInd2);
        // Calcul des nouvelles faces a partir de cette face
        // celle au centre
        b_facesOut[index*4] = st_face(nbEdges*2 + index*3, nbEdges*2 + index*3 + 1, nbEdges*2 + index*3 + 2);
        b_facesVertOut[index*4] = st_face(newVerticeInd1, newVerticeInd2, newVerticeInd3);
        // celle a partir de l'arrete 1
        uint indexEdge1 = 0;
        uint indexEdge2 = 0;
        if (b_edgesOut[current.y*2].x == b_edgesOut[current.z*2].x) {
            indexEdge1 = current.y*2;
            indexEdge2 = current.z*2;
        } else if (b_edgesOut[current.y*2+1].x == b_edgesOut[current.z*2].x) {
            indexEdge1 = current.y*2+1;
            indexEdge2 = current.z*2;
        } else if (b_edgesOut[current.y*2].x == b_edgesOut[current.z*2+1].x) {
            indexEdge1 = current.y*2;
            indexEdge2 = current.z*2+1;
        } else if (b_edgesOut[current.y*2+1].x == b_edgesOut[current.z*2+1].x) {
            indexEdge1 = current.y*2+1;
            indexEdge2 = current.z*2+1;
        }
        b_facesOut[index*4+1] = st_face(nbEdges*2 + index*3, indexEdge1, indexEdge2);
        b_facesVertOut[index*4+1] = st_face(b_edgesOut[indexEdge1].x, newVerticeInd3, newVerticeInd2);
        // celle a partir de l'arrete 2
        if (b_edgesOut[current.z*2].x == b_edgesOut[current.x*2].x) {
            indexEdge1 = current.z*2;
            indexEdge2 = current.x*2;
        } else if (b_edgesOut[current.z*2+1].x == b_edgesOut[current.x*2].x) {
            indexEdge1 = current.z*2+1;
            indexEdge2 = current.x*2;
        } else if (b_edgesOut[current.z*2].x == b_edgesOut[current.x*2+1].x) {
            indexEdge1 = current.z*2;
            indexEdge2 = current.x*2+1;
        } else if (b_edgesOut[current.z*2+1].x == b_edgesOut[current.x*2+1].x) {
            indexEdge1 = current.z*2+1;
            indexEdge2 = current.x*2+1;
        }
        b_facesOut[index*4+2] = st_face(nbEdges*2 + index*3+1, indexEdge1, indexEdge2);
        b_facesVertOut[index*4+2] = st_face(newVerticeInd3, b_edgesOut[indexEdge1].x, newVerticeInd1);
        // celle a partir de l'arrete 3
        if (b_edgesOut[current.x*2].x == b_edgesOut[current.y*2].x) {
            indexEdge1 = current.x*2;
            indexEdge2 = current.y*2;
        } else if (b_edgesOut[current.x*2+1].x == b_edgesOut[current.y*2].x) {
            indexEdge1 = current.x*2+1;
            indexEdge2 = current.y*2;
        } else if (b_edgesOut[current.x*2].x == b_edgesOut[current.y*2+1].x) {
            indexEdge1 = current.x*2;
            indexEdge2 = current.y*2+1;
        } else if (b_edgesOut[current.x*2+1].x == b_edgesOut[current.y*2+1].x) {
            indexEdge1 = current.x*2+1;
            indexEdge2 = current.y*2+1;
        }
        b_facesOut[index*4+3] = st_face(nbEdges*2 + index*3+2, indexEdge1, indexEdge2);
        b_facesVertOut[index*4+3] = st_face(newVerticeInd2, newVerticeInd1, b_edgesOut[indexEdge1].x);
    }
}
